Q = require 'q'
required = require 'flatten-required'
Info = require 'module-info'
Compiler = require 'source-compiler'
Module = require 'module'
path = require 'path'
fs = require 'fs'
escapeRegexp = require 'escape-regexp'
uglifyJs = require 'uglify-js'
cleanCss = require 'clean-css'

Package = require './Package'
Helpers = require '../Helpers'

class Builder extends Package


	pckg: null

	logger: null

	jquerify: false

	minify: false

	stats: false

	expose: true

	autoModule: ['.json', '.eco']


	constructor: (@pckg) ->
		if @pckg !instanceof Package
			throw new Error 'Package must be an instance of Package/Package'


	log: (message) ->
		if @logger != null
			return @logger.log(message)

		return message


	check: ->
		if !fs.existsSync(@pckg.getPath(@pckg.paths.package))
			throw new Error 'Package has not got package.json file.'

		@pckg.prepare()


	build: ->
		@log "Building package #{@pckg.name}"

		deferred = Q.defer()

		Q.all([
			@buildModules()
			@buildAutorun()
			@buildStyles()
		]).then( (data) =>
			result = '/** Generated by SimQ **/\n/** modules **/\n\n' + data[0]
			if data[1] != ''
				result += '\n\n/** run section **/\n\n' + data[1]

			result = result.replace(/\n/g, '\n\t')
			result = "(function() {\n\tvar __r__c__ = {};\n\t#{result}\n}).call(this);"

			if @minify == true
				@log 'Minifying javascript'
				result = uglifyJs.minify(result, fromString: true).code

				if data[2] != null
					@log 'Minifying styles'
					data[2] = cleanCss().minify(data[2])

			deferred.resolve(
				js: result
				css: data[2]
			)
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	buildModules: ->
		@log 'Building modules'

		@check()

		deferred = Q.defer()

		@prepareModules().then( (modules) =>
			c = [@loadMain()]

			for name, _path of modules
				c.push(@compileModule(name, _path))

			for alias, original of @pckg.aliases
				c.push(Q.resolve(" '#{alias}': function(exports, module) { module.exports = __r__c__.require('#{original}'); }\n"))

			Q.all(c).then( (data) =>
				main = data.shift()
				result = "#{main}({\n#{data}\n});"

				if @stats == true
					stats = JSON.stringify(@loadStats(modules))
					result += "\n__r__c__.require.__setStats(#{stats});"

				if @expose == true
					result += '\n\nwindow.require = __r__c__.require;'

				deferred.resolve(result)
			).fail( (err) ->
				deferred.reject(err)
			)
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	buildAutorun: ->
		@log 'Building autorun'

		@check()

		deferred = Q.defer()

		run = []
		for _path in @pckg.run
			run.push(@loadForAutorun(_path))

		Q.all(run).then( (data) ->
			deferred.resolve(data.join('\n\n'))
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	buildStyles: ->
		@log 'Building styles'

		@check()

		if @pckg.style == null
			return Q.resolve(null)

		deferred = Q.defer()
		options = {}
		if @pckg.style.dependencies != null
			options.dependents = @pckg.style.dependencies

		@log "Compiling styles from #{@pckg.style.in}"
		Compiler.compileFile(@pckg.style.in, options).then( (data) ->
			deferred.resolve(data)
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	loadForAutorun: (_path) ->
		deferred = Q.defer()

		if fs.existsSync(_path)
			@log "Added file #{_path} to autorun"
			Compiler.compileFile(_path).then( (data) =>
				p = path.relative(@pckg.getBasePath(), _path)
				data = "/** #{p} **/\n#{data}"
				deferred.resolve(data)
			).fail( (err) ->
				deferred.reject(err)
			)
		else
			@log "Adding module #{_path} to autorun"
			deferred.resolve("/** #{_path} **/\n__r__c__.require('#{_path}');")

		return deferred.promise


	prepareModules: ->
		deferred = Q.defer()

		required.findMany(@pckg.modules, true, require('../../data.json').supportedCores).then( (data) =>
			result = {}

			data.files = data.files.concat(@pckg.modules)
			data.files = data.files.filter( (el, pos) -> return data.files.indexOf(el) == pos)

			for file in data.files
				# module in package
				if @pckg.getPackageInfo().isFileInModule(file)
					name = '/' + @pckg.getPackageInfo().getModuleName(file, true)
					if @pckg.base != null && @pckg.paths.package != './package.json'
						buf = '/' + @pckg.base.replace(/^[\.\/]*/, '')
						name = name.replace(new RegExp('^' + buf), '')

					@log "Added module #{name} from #{file}"
					result[name] = file

				else
					dir = path.dirname(file)

					# installed npm module
					if Module.globalPaths.indexOf(dir) == -1
						info = Info.fromFile(file)
						name = info.getModuleName(file)

						baseName = escapeRegexp(path.basename(file))
						if name.match(new RegExp(baseName + '$')) == null
							fullName = info.getName() + '/' + path.relative(info.getPath(), file)
							@pckg.addAlias(fullName, name)
							@log "Created alias #{name} for #{fullName}"
							@log "Added npm module #{fullName} from #{file}"
							result[fullName] = file
						else
							@log "Added npm module #{name} from #{file}"
							result[name] = file


						# core module
					else
						name = path.basename(file, path.extname(file))
						@log "Added node core module #{name} + from #{file}"
						result[name] = file

			for name, _path in data.core
				if _path != null
					@log "Added node core module #{name} from #{_path}"
					result[name] = _path

			deferred.resolve(result)
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	compileModule: (name, _path) ->
		deferred = Q.defer()

		Compiler.compileFile(_path, {precompile: true, jquerify: @jquerify}).then( (result) =>
			@log "Compiled module #{name}"

			type = path.extname(_path)

			if @autoModule.indexOf(type) != -1
				result = "module.exports = #{result}"

			if result != ''
				result = '\n\n\t/** code **/\n\t' + result.replace(/\n/g, '\n\t') + '\n'
			else
				result = '\n'

			globals = '\t' + Helpers.getGlobalsForModule(name).join('\n').replace(/\n/g, '\n\t')
			result = " '#{name}': function(exports, module) {\n\n\t/** node globals **/\n#{globals}#{result}\n}"

			deferred.resolve(result)
		).fail( (err) ->
			deferred.reject(err)
		)

		return deferred.promise


	loadStats: (modules) ->
		@log 'Loading modules\' stats'

		result = {}
		for name, _path of modules
			stat = fs.statSync(_path)
			result[name] =
				atime: (new Date(stat.atime)).getTime()
				mtime: (new Date(stat.mtime)).getTime()
				ctime: (new Date(stat.ctime)).getTime()

		return result


	loadMain: ->
		deferred = Q.defer()

		_path = path.resolve(__dirname + '/../Browser/Module.js')
		fs.readFile(_path, encoding: 'utf8', (err, data) ->
			if err
				deferred.reject(err)
			else
				data = data.replace(/\s+$/, '').replace(/;$/, '')
				data = data.replace(/\%version\%/, Info.fromFile(__filename).getVersion())
				deferred.resolve(data)
		)

		return deferred.promise


module.exports = Builder