// Generated by CoffeeScript 1.6.3
(function() {
  var Application, Finder, Q, Uglify, fs, required, _path;

  _path = require('path');

  Uglify = require('uglify-js');

  Q = require('q');

  Finder = require('fs-finder');

  fs = require('fs');

  required = require('required');

  Application = (function() {
    Application.prototype.simq = null;

    Application.prototype.loader = null;

    Application.prototype.basePath = null;

    function Application(simq, loader, basePath) {
      this.simq = simq;
      this.loader = loader;
      this.basePath = basePath;
    }

    Application.prototype.parse = function(section, packageName) {
      var base, data,
        _this = this;
      base = this.basePath + '/' + (section.base ? section.base + '/' : '');
      data = {
        data: section,
        result: {
          modules: [],
          nodeModules: {},
          final: []
        }
      };
      return Q.resolve(data).then(function(data) {
        var deferred;
        deferred = Q.defer();
        _this.loadFiles(data.data.libs.begin, base).then(function(result) {
          data.result.final = result;
          return deferred.resolve(data);
        });
        return deferred.promise;
      }).then(function(data) {
        var deferred, modules;
        modules = _this.findModules(section.modules, section.base);
        deferred = Q.defer();
        _this.loader.loadModules(modules, section.base).then(function(modules) {
          data.result.modules = modules;
          return deferred.resolve(data);
        }, function(e) {
          return deferred.reject(e);
        });
        return deferred.promise;
      }).then(function(data) {
        var deferred;
        if (fs.existsSync(_this.basePath + '/node_modules')) {
          deferred = Q.defer();
          _this.findNodeModules().then(function(modulesData) {
            var core, info, infoData, _i, _len, _ref;
            core = modulesData.core.join(', ');
            if (core.length > 0) {
              console.warn('Package "' + packageName + '" may will not work, due to usage of these core modules: ' + core + '.');
            }
            info = {};
            _ref = modulesData.info;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              infoData = _ref[_i];
              info[infoData.moduleBase] = {
                name: infoData.module,
                path: infoData.modulePath
              };
            }
            data.result.nodeModules = info;
            return _this.loader.loadModules(modulesData.files).then(function(modules) {
              data.result.modules = data.result.modules.concat(modules);
              return deferred.resolve(data);
            });
          });
          return deferred.promise;
        } else {
          return Q.resolve(data);
        }
      }).then(function(data) {
        var alias, deferred, module, _ref;
        _ref = data.data.aliases;
        for (alias in _ref) {
          module = _ref[alias];
          data.result.modules.push('\'' + alias + '\': \'' + module + '\'');
        }
        deferred = Q.defer();
        _this.loader.loadFile(__dirname + '/../Module.js').then(function(content) {
          content = content.replace(/\s+$/, '').replace(/;$/, '');
          data.result.final.push(content + '({' + data.result.modules.join(',\n') + '\n});');
          data.result.final.push('require._setNodeInfo(' + JSON.stringify(data.result.nodeModules) + ');\n');
          return deferred.resolve(data);
        }, function(e) {
          return deferred.reject(e);
        });
        return deferred.promise;
      }).then(function(data) {
        var deferred;
        deferred = Q.defer();
        _this.loadFiles(data.data.libs.end, base).then(function(result) {
          data.result.final = data.result.final.concat(result);
          return deferred.resolve(data);
        });
        return deferred.promise;
      }).then(function(data) {
        var module, run, _i, _len, _ref;
        run = [];
        _ref = section.run;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          module = _ref[_i];
          run.push('this.require(\'' + module + '\');');
        }
        data.result.final.push(run.join('\n'));
        return Q.resolve(data);
      }).then(function(data) {
        var result;
        result = data.result.final.join('\n\n');
        if (!_this.simq.config.load()["debugger"].scripts) {
          result = Uglify.minify(result, {
            fromString: true
          }).code;
        }
        return Q.resolve(result);
      });
    };

    Application.prototype.loadFiles = function(paths, base) {
      var buf, data, deferred, files, fn, fns, i, path, _i, _j, _len, _ref,
        _this = this;
      files = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        path = _path.resolve(path);
        if (fs.existsSync(path)) {
          files.push(path);
        } else {
          files = files.concat(Finder.findFiles(path));
        }
      }
      data = {
        result: [],
        progress: null,
        files: files
      };
      fn = function(data) {
        var actual, deferred, file;
        deferred = Q.defer();
        actual = data.progress === null ? 0 : data.progress;
        file = data.files[actual].match(/^https?\:\/\//) === null ? base + data.files[actual] : data.files[actual];
        _this.loader.loadFile(file).then(function(content) {
          if (content !== null) {
            data.result.push(content);
          }
          return deferred.resolve(data);
        }, function(e) {
          return deferred.reject(e);
        });
        data.progress++;
        return deferred.promise;
      };
      fns = [];
      if (files.length > 0) {
        for (i = _j = 0, _ref = files.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
          fns.push(fn);
        }
      }
      deferred = Q.defer();
      buf = fns.reduce(function(soFar, f) {
        return soFar.then(f);
      }, Q.resolve(data));
      buf.then(function(libs) {
        return deferred.resolve(libs.result);
      });
      return deferred.promise;
    };

    Application.prototype.findModules = function(paths, base) {
      var filter, path, result, _i, _len;
      if (base == null) {
        base = null;
      }
      result = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if (base !== null) {
          path = './' + base + '/' + path;
        }
        path = _path.resolve(this.basePath + '/' + path);
        if (fs.existsSync(path) && fs.statSync(path).isFile()) {
          result.push(path);
        } else {
          filter = function(stat, file) {
            return file.substr(file.length - 1) !== '~';
          };
          path = Finder.parseDirectory(path);
          result = result.concat((new Finder(path.directory)).recursively().filter(filter).findFiles(path.mask));
        }
      }
      return result;
    };

    Application.prototype.findNodeModules = function() {
      var deferred, file, info, modules, _i, _len, _ref,
        _this = this;
      deferred = Q.defer();
      modules = {
        files: [],
        info: []
      };
      _ref = Finder.findFiles(_path.resolve(this.basePath + '/node_modules/*/package.json'));
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        info = this.getMainNodeModule(file, JSON.parse(fs.readFileSync(file, {
          encoding: 'utf8'
        })));
        modules.files.push(info.file);
        modules.info.push(info);
      }
      this.loadNodeModuleDependencies(modules.files).then(function(data) {
        return deferred.resolve({
          files: data.files,
          info: modules.info,
          core: data.core
        });
      });
      return deferred.promise;
    };

    Application.prototype.findNodeFile = function(path) {
      path = _path.resolve(path);
      if (fs.existsSync(path)) {
        if (fs.statSync(path).isDirectory()) {
          return this.findNodeFile(path + '/index');
        } else {
          return path;
        }
      } else if (fs.existsSync(path + '.js')) {
        return path + '.js';
      } else if (fs.existsSync(path + '.json')) {
        return path + '.json';
      } else {
        return null;
      }
    };

    Application.prototype.loadNodeModuleDependencies = function(files) {
      var buf, data, deferred, fn, fns, i, _i, _ref,
        _this = this;
      data = {
        result: [],
        core: [],
        progress: null,
        files: files
      };
      fn = function(data) {
        var actual, deferred;
        deferred = Q.defer();
        actual = data.progress === null ? 0 : data.progress;
        data.result.push(data.files[actual]);
        required(data.files[actual], {
          ignoreMissing: true
        }, function(e, deps) {
          var dep, result, _i, _len;
          if (e) {
            return deferred.reject(e);
          } else {
            result = [];
            for (_i = 0, _len = deps.length; _i < _len; _i++) {
              dep = deps[_i];
              if (dep.core === true) {
                if (data.core.indexOf(dep.id) === -1) {
                  data.core.push(dep.id);
                }
              } else {
                result.push(dep.filename);
                if (dep.deps.length > 0) {
                  result = result.concat(_this.parseDependencies(dep));
                }
              }
            }
            result = result.filter(function(el, pos, self) {
              return self.indexOf(el) === pos;
            });
            data.result = data.result.concat(result);
            return deferred.resolve(data);
          }
        });
        data.progress++;
        return deferred.promise;
      };
      fns = [];
      for (i = _i = 1, _ref = files.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        fns.push(fn);
      }
      deferred = Q.defer();
      buf = fns.reduce(function(soFar, f) {
        return soFar.then(f);
      }, Q.resolve(data));
      buf.then(function(data) {
        return deferred.resolve({
          core: data.core,
          files: data.result
        });
      });
      return deferred.promise;
    };

    Application.prototype.getMainNodeModule = function(file, pckgInfo) {
      var main, match, result;
      result = {
        file: null,
        moduleBase: null,
        modulePath: null,
        module: null
      };
      main = typeof pckgInfo.main === 'undefined' ? './index' : pckgInfo.main;
      main = _path.resolve(_path.dirname(file), main);
      result.file = main = this.findNodeFile(main);
      result.moduleBase = _path.relative(this.basePath, _path.dirname(file));
      main = _path.relative(_path.resolve(this.basePath), main);
      result.modulePath = main.substring(0, main.length - _path.extname(main).length);
      match = result.modulePath.match(/node_modules\/([a-z0-9-_]+)/g);
      result.module = match[match.length - 1].split('/')[1];
      return result;
    };

    Application.prototype.parseDependencies = function(dep) {
      var result, sub, _i, _len, _ref;
      result = [];
      _ref = dep.deps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sub = _ref[_i];
        if (sub.core !== true) {
          result.push(sub.filename);
          if (sub.deps.length > 0) {
            result = result.concat(this.parseDependencies(sub));
          }
        }
      }
      return result;
    };

    return Application;

  })();

  module.exports = Application;

}).call(this);
