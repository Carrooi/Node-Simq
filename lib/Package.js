// Generated by CoffeeScript 1.6.3
(function() {
  var Finder, Helpers, Module, Package, Q, fs, path, required;

  fs = require('fs');

  path = require('path');

  Q = require('q');

  required = require('required');

  Finder = require('fs-finder');

  Module = require('module');

  Helpers = require('./Helpers');

  Package = (function() {
    Package.prototype.basePath = null;

    function Package(basePath) {
      this.basePath = basePath;
    }

    Package.prototype.isInModule = function(_path) {
      var pckg;
      pckg = this.findModulePackageFile(_path, this.basePath);
      return pckg !== null && pckg !== this.basePath + '/package.json';
    };

    Package.prototype.getModuleName = function(_path) {
      var pckg;
      if (!this.isInModule(_path)) {
        return null;
      }
      pckg = this.findModulePackageFile(_path);
      return JSON.parse(fs.readFileSync(pckg, {
        encoding: 'utf8'
      })).name;
    };

    Package.prototype.getModuleBaseDir = function(_path) {
      var pckg;
      if (!this.isInModule(_path)) {
        return null;
      }
      pckg = this.findModulePackageFile(_path);
      return path.dirname(pckg);
    };

    Package.prototype.resolveModuleName = function(_path) {
      _path = path.resolve(_path);
      if (fs.existsSync(_path)) {
        if (fs.statSync(_path).isDirectory()) {
          return this.resolveModuleName(_path + '/index');
        } else {
          return _path;
        }
      } else if (fs.existsSync(_path + '.js')) {
        return _path + '.js';
      } else if (fs.existsSync(_path + '.json')) {
        return _path + '.json';
      } else if (fs.existsSync(_path + '.coffee')) {
        return _path + '.coffee';
      } else if (fs.existsSync(_path + '.ts')) {
        return _path + '.ts';
      } else if (fs.existsSync(_path + '.eco')) {
        return _path + '.eco';
      } else {
        return null;
      }
    };

    Package.prototype.findModulePackageFile = function(_path, limit) {
      if (limit == null) {
        limit = null;
      }
      return Finder["in"](path.dirname(_path)).lookUp(limit).findFirst().findFiles('package.json');
    };

    Package.prototype.loadModuleInfo = function(_path) {
      var dir, main, pckg, result;
      if (!this.isInModule(_path)) {
        return null;
      }
      pckg = this.findModulePackageFile(_path);
      pckg = JSON.parse(fs.readFileSync(pckg, {
        encoding: 'utf8'
      }));
      main = typeof pckg.main === 'undefined' ? './index' : pckg.main;
      dir = this.getModuleBaseDir(_path);
      main = dir + '/' + main;
      main = this.resolveModuleName(main);
      result = {
        file: _path,
        name: this.getModuleName(_path),
        main: path.normalize(main),
        dir: dir
      };
      return result;
    };

    Package.prototype.findDependencies = function(_path) {
      var deferred, info, result,
        _this = this;
      if (path.extname(_path) !== '.js') {
        result = {
          files: [_path],
          core: [],
          node: {}
        };
        if ((info = this.loadModuleInfo(_path)) !== null) {
          result.node[info.dir] = {
            name: info.name,
            main: info.main
          };
        }
        return Q.resolve(result);
      }
      deferred = Q.defer();
      required(_path, {
        ignoreMissing: true
      }, function(e, deps) {
        var dep, ext, file, res, _i, _j, _len, _len1, _ref;
        if (e) {
          return deferred.reject(e);
        } else {
          res = {
            files: [_path],
            core: [],
            node: {}
          };
          for (_i = 0, _len = deps.length; _i < _len; _i++) {
            dep = deps[_i];
            ext = _this.parseDependencies(dep);
            res.files = res.files.concat(ext.files);
            res.core = res.core.concat(ext.core);
          }
          _ref = res.files;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            file = _ref[_j];
            if ((info = _this.loadModuleInfo(file)) !== null) {
              res.files.push(info.main);
              res.node[info.dir] = {
                name: info.name,
                main: info.main
              };
            }
          }
          res.files = Helpers.removeDuplicates(res.files);
          res.core = Helpers.removeDuplicates(res.core);
          return deferred.resolve(res);
        }
      });
      return deferred.promise;
    };

    Package.prototype.parseDependencies = function(dep) {
      var ext, result, sub, _i, _len, _ref;
      result = {
        files: [],
        core: []
      };
      if (dep.core === true) {
        result.core.push(dep.id);
      } else {
        result.files.push(dep.filename);
        _ref = dep.deps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sub = _ref[_i];
          ext = this.parseDependencies(sub);
          result.files = result.files.concat(ext.files);
          result.core = result.core.concat(ext.core);
        }
      }
      return result;
    };

    Package.prototype.findDependenciesForModules = function(paths) {
      var modules, _i, _len, _path;
      modules = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        _path = paths[_i];
        modules.push(this.findDependencies(_path));
      }
      return Q.all(modules).then(function(modules) {
        var info, m, name, result, _j, _k, _l, _len1, _len2, _len3, _ref, _ref1, _ref2;
        result = {
          files: [],
          core: [],
          node: {}
        };
        for (_j = 0, _len1 = modules.length; _j < _len1; _j++) {
          m = modules[_j];
          _ref = m.files;
          for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
            name = _ref[_k];
            if (result.files.indexOf(name) === -1) {
              result.files.push(name);
            }
          }
          _ref1 = m.core;
          for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
            name = _ref1[_l];
            if (result.core.indexOf(name) === -1) {
              result.core.push(name);
            }
          }
          _ref2 = m.node;
          for (name in _ref2) {
            info = _ref2[name];
            if (typeof result.node[name] === 'undefined') {
              result.node[name] = info;
            }
          }
        }
        return Q.resolve(result);
      });
    };

    Package.prototype.getGlobalsForModule = function(name) {
      var globals, key, result, value;
      globals = {
        require: "function(name) {return __require(name, '" + name + "');}",
        __filename: "'" + name + "'",
        __dirname: '\'' + path.dirname(name) + '\''
      };
      result = [];
      for (key in globals) {
        value = globals[key];
        result.push("var " + key + " = " + value + ";");
      }
      return result;
    };

    Package.prototype.parseNodeInfo = function(data, basePath) {
      var base, info, m, main, result;
      result = {};
      for (m in data) {
        info = data[m];
        main = path.relative(basePath, info.main);
        base = path.relative(basePath, m);
        main = main.replace(/^[./]+/, '');
        base = base.replace(/^[./]+/, '');
        result[info.name] = {
          base: base,
          path: main
        };
      }
      return result;
    };

    Package.prototype.findSystemNodeModulePath = function(name) {
      var dir, _i, _len, _path, _ref;
      _ref = Module.globalPaths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        _path = "" + dir + "/" + name + ".js";
        if (fs.existsSync(_path) && fs.statSync(_path).isFile()) {
          return _path;
        }
      }
      return null;
    };

    return Package;

  })();

  module.exports = Package;

}).call(this);
