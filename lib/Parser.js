// Generated by CoffeeScript 1.6.2
(function() {
  var Loader, Parser, fs, less, _path;

  Loader = require('./Loader');

  _path = require('path');

  less = require('less');

  fs = require('fs');

  Parser = (function() {
    Parser.prototype.simq = null;

    Parser.prototype.loader = null;

    Parser.prototype.basePath = null;

    function Parser(simq, loader, basePath) {
      this.simq = simq;
      this.loader = loader;
      this.basePath = basePath;
    }

    Parser.prototype.parseApplication = function(section) {
      var alias, ext, lib, module, modules, name, path, result, run, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;

      result = new Array;
      if (section.libs && section.libs.begin) {
        _ref = section.libs.begin;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          lib = _ref[_i];
          result.push(this.loader.loadFile(this.basePath + '/' + lib));
        }
      }
      if (section.modules || section.aliases) {
        modules = new Array;
        if (section.modules) {
          _ref1 = section.modules;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            path = _ref1[_j];
            ext = _path.extname(path);
            name = path.replace(new RegExp('\\*?' + ext + '$'), '');
            ext = ext === '' ? null : ext.substring(1);
            if (name.substring(name.length - 1) === '/') {
              modules = modules.concat(this.loader.loadModules(this.basePath + '/' + name, ext));
            } else {
              modules.push(this.loader.loadModule(this.basePath + '/' + path));
            }
          }
        }
        if (section.aliases) {
          _ref2 = section.aliases;
          for (alias in _ref2) {
            module = _ref2[alias];
            modules.push('\'' + alias + '\': \'' + module + '\'');
          }
        }
        module = this.loader.loadFile(__dirname + '/Module.js').replace(/\s+$/, '').replace(/;$/, '');
        result.push(module + '({' + modules.join(',\n') + '\n});');
      }
      if (section.libs && section.libs.end) {
        _ref3 = section.libs.end;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          lib = _ref3[_k];
          result.push(this.loader.loadFile(this.basePath + '/' + lib));
        }
      }
      if (section.run) {
        run = new Array;
        _ref4 = section.run;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          module = _ref4[_l];
          run.push('this.require(\'' + module + '\');');
        }
        result.push(run.join('\n'));
      }
      result = result.join('\n\n');
      return result;
    };

    Parser.prototype.parseStyles = function(path, fn) {
      var file, options;

      path = _path.resolve(path);
      file = fs.readFileSync(path, 'utf8').toString();
      options = {
        compress: !this.simq.debug
      };
      less.render(file, options, function(e, content) {
        return fn(content);
      });
      return this;
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
