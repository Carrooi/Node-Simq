// Generated by CoffeeScript 1.6.3
(function() {
  var Builder, Compiler, Helpers, Info, Module, Package, Q, cleanCss, escapeRegexp, fs, path, required, uglifyJs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Q = require('q');

  required = require('flatten-required');

  Info = require('module-info');

  Compiler = require('source-compiler');

  Module = require('module');

  path = require('path');

  fs = require('fs');

  escapeRegexp = require('escape-regexp');

  uglifyJs = require('uglify-js');

  cleanCss = require('clean-css');

  Package = require('./Package');

  Helpers = require('../Helpers');

  Builder = (function(_super) {
    __extends(Builder, _super);

    Builder.prototype.pckg = null;

    Builder.prototype.logger = null;

    Builder.prototype.jquerify = false;

    Builder.prototype.minify = false;

    Builder.prototype.stats = false;

    Builder.prototype.expose = true;

    Builder.prototype.autoModule = ['.json', '.eco'];

    function Builder(pckg) {
      this.pckg = pckg;
      if (!(this.pckg instanceof Package)) {
        throw new Error('Package must be an instance of Package/Package');
      }
    }

    Builder.prototype.log = function(message) {
      if (this.logger !== null) {
        return this.logger.log(message);
      }
      return message;
    };

    Builder.prototype.check = function() {
      if (!fs.existsSync(this.pckg.getPath(this.pckg.paths["package"]))) {
        throw new Error('Package has not got package.json file.');
      }
      return this.pckg.prepare();
    };

    Builder.prototype.build = function() {
      var deferred,
        _this = this;
      this.log("Building package " + this.pckg.name);
      deferred = Q.defer();
      Q.all([this.buildModules(), this.buildAutorun(), this.buildStyles()]).then(function(data) {
        var result;
        result = '/** Generated by SimQ **/\n/** modules **/\n\n' + data[0];
        if (data[1] !== '') {
          result += '\n\n/** run section **/\n\n' + data[1];
        }
        result = result.replace(/\n/g, '\n\t');
        result = "(function() {\n\tvar __r__c__ = this;\n\t" + result + "\n}).call({});";
        if (_this.minify === true) {
          _this.log('Minifying javascript');
          result = uglifyJs.minify(result, {
            fromString: true
          }).code;
          _this.log('Minifying styles');
          data[2] = cleanCss().minify(data[2]);
        }
        return deferred.resolve({
          js: result,
          css: data[2]
        });
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.buildModules = function() {
      var deferred,
        _this = this;
      this.log('Building modules');
      this.check();
      deferred = Q.defer();
      this.prepareModules().then(function(modules) {
        var alias, c, name, original, _path, _ref;
        c = [_this.loadMain()];
        for (name in modules) {
          _path = modules[name];
          c.push(_this.compileModule(name, _path));
        }
        _ref = _this.pckg.aliases;
        for (alias in _ref) {
          original = _ref[alias];
          c.push(Q.resolve(" '" + alias + "': function(exports, module) { module.exports = __r__c__.require('" + original + "'); }\n"));
        }
        return Q.all(c).then(function(data) {
          var expose, main, result, stats, version;
          main = data.shift();
          result = "" + main + "({\n" + data + "\n});";
          if (_this.stats === true) {
            stats = JSON.stringify(_this.loadStats(modules));
            result += "\n__r__c__.require.__setStats(" + stats + ");";
          }
          version = Info.fromFile(__filename).getVersion();
          expose = _this.expose === true ? '\n\nwindow.require = __r__c__.require;' : '';
          result += "\n__r__c__.require.version = '" + version + "';" + expose;
          return deferred.resolve(result);
        }).fail(function(err) {
          return deferred.reject(err);
        });
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.buildAutorun = function() {
      var deferred, run, _i, _len, _path, _ref;
      this.log('Building autorun');
      this.check();
      deferred = Q.defer();
      run = [];
      _ref = this.pckg.run;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _path = _ref[_i];
        run.push(this.loadForAutorun(_path));
      }
      Q.all(run).then(function(data) {
        return deferred.resolve(data.join('\n\n'));
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.buildStyles = function() {
      var deferred, options;
      this.log('Building styles');
      this.check();
      if (this.pckg.style === null) {
        return Q.resolve(null);
      }
      deferred = Q.defer();
      options = {};
      if (this.pckg.style.dependencies !== null) {
        options.dependents = this.pckg.style.dependencies;
      }
      this.log("Compiling styles from " + this.pckg.style["in"]);
      Compiler.compileFile(this.pckg.style["in"], options).then(function(data) {
        return deferred.resolve(data);
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.loadForAutorun = function(_path) {
      var deferred,
        _this = this;
      deferred = Q.defer();
      if (fs.existsSync(_path)) {
        this.log("Added file " + _path + " to autorun");
        Compiler.compileFile(_path).then(function(data) {
          var p;
          p = path.relative(_this.pckg.getBasePath(), _path);
          data = "/** " + p + " **/\n" + data;
          return deferred.resolve(data);
        }).fail(function(err) {
          return deferred.reject(err);
        });
      } else {
        this.log("Adding module " + _path + " to autorun");
        deferred.resolve("/** " + _path + " **/\n__r__c__.require('" + _path + "');");
      }
      return deferred.promise;
    };

    Builder.prototype.prepareModules = function() {
      var deferred,
        _this = this;
      deferred = Q.defer();
      required.findMany(this.pckg.modules, true, require('../../data.json').supportedCores).then(function(data) {
        var baseName, buf, dir, file, fullName, info, name, result, _i, _j, _len, _len1, _path, _ref, _ref1;
        result = {};
        data.files = data.files.concat(_this.pckg.modules);
        data.files = data.files.filter(function(el, pos) {
          return data.files.indexOf(el) === pos;
        });
        _ref = data.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (_this.pckg.getPackageInfo().isFileInModule(file)) {
            name = '/' + _this.pckg.getPackageInfo().getModuleName(file, true);
            if (_this.pckg.base !== null && _this.pckg.paths["package"] !== './package.json') {
              buf = '/' + _this.pckg.base.replace(/^[\.\/]*/, '');
              name = name.replace(new RegExp('^' + buf), '');
            }
            _this.log("Added module " + name + " from " + file);
            result[name] = file;
          } else {
            dir = path.dirname(file);
            if (Module.globalPaths.indexOf(dir) === -1) {
              info = Info.fromFile(file);
              name = info.getModuleName(file);
              baseName = escapeRegexp(path.basename(file));
              if (name.match(new RegExp(baseName + '$')) === null) {
                fullName = info.getName() + '/' + path.relative(info.getPath(), file);
                _this.pckg.addAlias(fullName, name);
                _this.log("Created alias " + name + " for " + fullName);
                _this.log("Added npm module " + fullName + " from " + file);
                result[fullName] = file;
              } else {
                _this.log("Added npm module " + name + " from " + file);
                result[name] = file;
              }
            } else {
              name = path.basename(file, path.extname(file));
              _this.log("Added node core module " + name + " + from " + file);
              result[name] = file;
            }
          }
        }
        _ref1 = data.core;
        for (_path = _j = 0, _len1 = _ref1.length; _j < _len1; _path = ++_j) {
          name = _ref1[_path];
          if (_path !== null) {
            _this.log("Added node core module " + name + " from " + _path);
            result[name] = _path;
          }
        }
        return deferred.resolve(result);
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.compileModule = function(name, _path) {
      var deferred,
        _this = this;
      deferred = Q.defer();
      Compiler.compileFile(_path, {
        precompile: true,
        jquerify: this.jquerify
      }).then(function(result) {
        var globals, type;
        _this.log("Compiled module " + name);
        type = path.extname(_path);
        if (_this.autoModule.indexOf(type) !== -1) {
          result = "module.exports = " + result;
        }
        if (result !== '') {
          result = '\n\n\t/** code **/\n\t' + result.replace(/\n/g, '\n\t') + '\n';
        } else {
          result = '\n';
        }
        globals = '\t' + Helpers.getGlobalsForModule(name).join('\n').replace(/\n/g, '\n\t');
        result = " '" + name + "': function(exports, module) {\n\n\t/** node globals **/\n" + globals + result + "\n}";
        return deferred.resolve(result);
      }).fail(function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Builder.prototype.loadStats = function(modules) {
      var name, result, stat, _path;
      this.log('Loading modules\' stats');
      result = {};
      for (name in modules) {
        _path = modules[name];
        stat = fs.statSync(_path);
        result[name] = {
          atime: (new Date(stat.atime)).getTime(),
          mtime: (new Date(stat.mtime)).getTime(),
          ctime: (new Date(stat.ctime)).getTime()
        };
      }
      return result;
    };

    Builder.prototype.loadMain = function() {
      var deferred, _path;
      deferred = Q.defer();
      _path = path.resolve(__dirname + '/../Browser/Module.js');
      fs.readFile(_path, {
        encoding: 'utf8'
      }, function(err, data) {
        if (err) {
          return deferred.reject(err);
        } else {
          data = data.replace(/\s+$/, '').replace(/;$/, '');
          return deferred.resolve(data);
        }
      });
      return deferred.promise;
    };

    return Builder;

  })(Package);

  module.exports = Builder;

}).call(this);
