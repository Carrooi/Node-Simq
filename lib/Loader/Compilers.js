// Generated by CoffeeScript 1.6.3
(function() {
  var Compilers, Q, coffee, eco, less, path, stylus,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffee = require('coffee-script');

  eco = require('eco');

  less = require('less');

  Q = require('q');

  path = require('path');

  stylus = require('stylus');

  Compilers = (function() {
    Compilers.prototype.simq = null;

    function Compilers(simq) {
      this.simq = simq;
    }

    Compilers.prototype.hasLoader = function(ext) {
      ext = ext.toLowerCase();
      return typeof this[ext + 'Loader'] !== 'undefined';
    };

    Compilers.prototype.prepare = function(file, content) {
      var deferred, ext;
      deferred = Q.defer();
      file = path.resolve(file);
      ext = path.extname(file).substr(1).toLowerCase();
      if (this.hasLoader(ext)) {
        this[ext + 'Loader'](content, file).then(function(content) {
          return deferred.resolve(content.replace(/^\s+|\s+$/g, ''));
        }, function(e) {
          return deferred.reject(e);
        });
      } else {
        deferred.resolve(content.replace(/^\s+|\s+$/g, ''));
      }
      return deferred.promise;
    };

    Compilers.prototype.hasCompiler = function(ext) {
      ext = ext.toLowerCase();
      return typeof this[ext + 'Compiler'] !== 'undefined';
    };

    Compilers.prototype.compile = function(file, content) {
      var deferred, ext;
      deferred = Q.defer();
      file = path.resolve(file);
      ext = path.extname(file).substr(1).toLowerCase();
      if (!this.hasCompiler(ext)) {
        throw new Error('File type ' + ext + ' is not supported.');
      }
      this[ext + 'Compiler'](content, file).then(function(content) {
        return deferred.resolve(content);
      });
      return deferred.promise;
    };

    Compilers.prototype.coffeeLoader = function(content, file) {
      var deferred, e;
      deferred = Q.defer();
      try {
        deferred.resolve(coffee.compile(content, {
          filename: file,
          literate: false
        }));
      } catch (_error) {
        e = _error;
        deferred.reject(e);
      }
      return deferred.promise;
    };

    Compilers.prototype.ecoLoader = function(content) {
      return Q.resolve(eco.precompile(content));
    };

    Compilers.prototype.lessLoader = function(content, file) {
      var debug, deferred, e, options,
        _this = this;
      deferred = Q.defer();
      debug = this.simq.config.load()["debugger"];
      options = {
        paths: [path.dirname(file)],
        optimization: 1,
        filename: file,
        rootpath: '',
        relativeUrls: false,
        strictImports: false,
        compress: !debug.styles
      };
      if (debug.styles && debug.sourceMap) {
        options.dumpLineNumbers = 'mediaquery';
      }
      try {
        less.render(content, options, function(e, content) {
          if (e) {
            return deferred.reject(_this.parseLessError(e));
          } else {
            return deferred.resolve(content);
          }
        });
      } catch (_error) {
        e = _error;
        deferred.reject(this.parseLessError(e));
      }
      return deferred.promise;
    };

    Compilers.prototype.stylLoader = function(content, file) {
      var deferred,
        _this = this;
      deferred = Q.defer();
      stylus(content).include(path.dirname(file)).set('include css', (__indexOf.call(process.argv, '--includeCss') >= 0)).set('compress', !this.simq.config.load()["debugger"].styles).render(function(e, content) {
        if (e) {
          return deferred.reject(_this.parseStylusError(e, file));
        } else {
          return deferred.resolve(content);
        }
      });
      return deferred.promise;
    };

    Compilers.prototype.jsCompiler = function(content) {
      return Q.resolve('return (function() {\n' + content + '\n\t\t}).call(this);');
    };

    Compilers.prototype.coffeeCompiler = function(content) {
      return Q.resolve('return ' + content);
    };

    Compilers.prototype.jsonCompiler = function(content) {
      return Q.resolve('module.exports = ' + content);
    };

    Compilers.prototype.ecoCompiler = function(content) {
      var module;
      if (this.simq.config.load().template.jquerify === true) {
        module = "module.exports = function (values, data) {\n	var $  = jQuery, result = $();\n	values = $.makeArray(values);\n	data = data || {};\n	for (var i=0; i < values.length; i++) {\n		var value = $.extend({}, values[i], data, {index: i});\n		var elem  = $((" + content + ")(value));\n		elem.data('item', value);\n		$.merge(result, elem);\n	}\n	return result;\n};";
      } else {
        module = 'module.exports = ' + content;
      }
      return Q.resolve(module);
    };

    Compilers.prototype.parseLessError = function(e) {
      var err;
      err = new Error(e.type + 'Error: ' + e.message.replace(/[\s\.]+$/, '') + ' in ' + e.filename + ':' + e.line + ':' + e.column);
      err.type = e.type;
      err.filename = e.filename;
      err.line = e.line;
      err.column = e.column;
      return err;
    };

    Compilers.prototype.parseStylusError = function(e, file) {
      var data, err, line, message;
      data = e.message.split('\n');
      line = data[0].split(':')[1];
      message = data[data.length - 2];
      err = new Error(message + ' in ' + file + ':' + line);
      err.type = e.name;
      err.filename = file;
      err.line = line;
      return err;
    };

    return Compilers;

  })();

  module.exports = Compilers;

}).call(this);
