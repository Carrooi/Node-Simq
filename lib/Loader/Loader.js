// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Compilers, FileStorage, Finder, Loader, Q, fs, http, _path;

  Q = require('q');

  _path = require('path');

  fs = require('fs');

  http = require('http');

  Cache = require('cache-storage');

  FileStorage = require('cache-storage/Storage/FileStorage');

  Finder = require('fs-finder');

  Compilers = require('./Compilers');

  Loader = (function() {
    Loader.CACHE_NAMESPACE = 'simq.files';

    Loader.prototype.simq = null;

    Loader.prototype.compilers = null;

    Loader.prototype.cache = null;

    function Loader(simq) {
      var cacheDirectory;
      this.simq = simq;
      this.compilers = new Compilers(this.simq);
      cacheDirectory = this.simq.config.load().cache.directory;
      if (cacheDirectory !== null) {
        this.cache = new Cache(new FileStorage(_path.resolve(cacheDirectory)), Loader.CACHE_NAMESPACE);
      }
    }

    Loader.prototype.isCacheAllowed = function(path, packageName) {
      var dependencies, _ref;
      if (packageName == null) {
        packageName = null;
      }
      if (this.cache === null) {
        return false;
      }
      if ((_ref = _path.extname(path)) !== '.less' && _ref !== '.scss' && _ref !== '.styl') {
        return true;
      }
      if (packageName === null) {
        return false;
      }
      dependencies = this.simq.config.load().packages[packageName].style.dependencies;
      if (dependencies.length > 0) {
        return dependencies;
      } else {
        return false;
      }
    };

    Loader.prototype.loadFile = function(path, packageName) {
      var data,
        _this = this;
      if (packageName == null) {
        packageName = null;
      }
      if (path.match(/^https?\:\/\//) === null) {
        path = _path.resolve(path);
      }
      if (_path.basename(path, _path.extname(path)).substr(0, 1) === '.' || path.substring(path.length - 1) === '~') {
        return Q.resolve(null);
      }
      if (this.isCacheAllowed(path, packageName) !== false && (data = this.cache.load(_path.resolve(path))) !== null) {
        return Q.resolve(data);
      }
      return (function() {
        var deferred, ext;
        deferred = Q.defer();
        ext = _path.extname(path).substr(1);
        if (path.match(/^https?\:\/\//) === null) {
          path = _path.resolve(path);
          fs.readFile(path, 'utf-8', function(e, data) {
            if (e) {
              return deferred.reject(new Error(e));
            } else {
              return deferred.resolve({
                path: path,
                ext: ext,
                content: data
              });
            }
          });
        } else {
          http.get(path, function(res) {
            data = '';
            res.setEncoding('utf-8');
            res.on('data', function(chunk) {
              return data += chunk;
            });
            return res.on('end', function() {
              return deferred.resolve({
                path: path,
                ext: ext,
                content: data
              });
            });
          }).on('error', function(e) {
            return deferred.reject(new Error(e));
          });
        }
        return deferred.promise;
      })().then(function(file) {
        var deferred;
        deferred = Q.defer();
        _this.compilers.prepare(path, file.content).then(function(content) {
          var dependencies, files, _i, _len;
          if ((dependencies = _this.isCacheAllowed(file.path, packageName)) !== false && _this.cache.load(file.path) === null) {
            files = [file.path];
            if (dependencies !== true) {
              for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
                path = dependencies[_i];
                files = files.concat(Finder.findFiles(path));
              }
            }
            _this.cache.save(file.path, content, {
              files: files
            });
          }
          return deferred.resolve(content);
        }, function(e) {
          return deferred.reject(e);
        });
        return deferred.promise;
      });
    };

    Loader.prototype.loadModule = function(path, base) {
      var _this = this;
      if (base == null) {
        base = null;
      }
      return (function() {
        var deferred, ext;
        deferred = Q.defer();
        path = _path.resolve(path);
        ext = _path.extname(path).substr(1);
        if (!_this.compilers.hasCompiler(ext)) {
          deferred.reject(new Error('File type ' + ext + ' is not supported'));
        } else {
          _this.loadFile(path).then(function(content) {
            if (content === null) {
              return deferred.resolve(null);
            } else {
              return deferred.resolve({
                path: path,
                content: content
              });
            }
          }, function(e) {
            return deferred.reject(e);
          });
        }
        return deferred.promise;
      })().then(function(file) {
        var deferred, name;
        if (file === null) {
          return Q.resolve(null);
        }
        deferred = Q.defer();
        name = _this.simq.getModuleName(file.path);
        if (base !== null) {
          name = name.replace(new RegExp('^' + base + '/'), '');
        }
        _this.compilers.compile(file.path, file.content).then(function(content) {
          return deferred.resolve('\'' + name + '\': function(exports, _r, module) {\nvar require = function(name) {return _r(name, \'' + name + '\');};\n\t\t' + content + '\n\t}');
        });
        return deferred.promise;
      });
    };

    return Loader;

  })();

  module.exports = Loader;

}).call(this);
