// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Compilers, FileStorage, Loader, Q, fs, http, _path;

  Q = require('q');

  _path = require('path');

  fs = require('fs');

  http = require('http');

  Cache = require('cache-storage');

  FileStorage = require('cache-storage/Storage/FileStorage');

  Compilers = require('./Compilers');

  Loader = (function() {
    Loader.CACHE_NAMESPACE = 'simq.files';

    Loader.prototype.simq = null;

    Loader.prototype.compilers = null;

    Loader.prototype.cache = null;

    function Loader(simq) {
      var cacheDirectory;
      this.simq = simq;
      this.compilers = new Compilers(this.simq);
      cacheDirectory = this.simq.config.load().cache.directory;
      if (cacheDirectory !== null) {
        this.cache = new Cache(new FileStorage(_path.resolve(cacheDirectory)), Loader.CACHE_NAMESPACE);
      }
    }

    Loader.prototype.isCacheAllowed = function(path) {
      var _ref;
      return this.cache !== null && ((_ref = _path.extname(path)) !== '.less' && _ref !== '.scss' && _ref !== '.styl');
    };

    Loader.prototype.loadFile = function(path) {
      var data,
        _this = this;
      if (path.match(/^https?\:\/\//) === null) {
        path = _path.resolve(path);
      }
      if (_path.basename(path, _path.extname(path)).substr(0, 1) === '.' || path.substring(path.length - 1) === '~') {
        return Q.resolve(null);
      }
      if (this.isCacheAllowed(path) && (data = this.cache.load(_path.resolve(path))) !== null) {
        return Q.resolve(data);
      }
      return (function() {
        var deferred, ext;
        deferred = Q.defer();
        ext = _path.extname(path).substr(1);
        if (path.match(/^https?\:\/\//) === null) {
          path = _path.resolve(path);
          fs.readFile(path, 'utf-8', function(e, data) {
            if (e) {
              return deferred.reject(new Error(e));
            } else {
              return deferred.resolve({
                path: path,
                ext: ext,
                content: data
              });
            }
          });
        } else {
          http.get(path, function(res) {
            data = '';
            res.setEncoding('utf-8');
            res.on('data', function(chunk) {
              return data += chunk;
            });
            return res.on('end', function() {
              return deferred.resolve({
                path: path,
                ext: ext,
                content: data
              });
            });
          }).on('error', function(e) {
            return deferred.reject(new Error(e));
          });
        }
        return deferred.promise;
      })().then(function(file) {
        var deferred;
        deferred = Q.defer();
        _this.compilers.prepare(path, file.content).then(function(content) {
          if (_this.isCacheAllowed(file.path) && _this.cache.load(file.path) === null) {
            _this.cache.save(file.path, content, {
              files: [file.path]
            });
          }
          return deferred.resolve(content);
        }, function(e) {
          return deferred.reject(e);
        });
        return deferred.promise;
      });
    };

    Loader.prototype.loadModule = function(path, base) {
      var _this = this;
      if (base == null) {
        base = null;
      }
      return (function() {
        var deferred, ext;
        deferred = Q.defer();
        path = _path.resolve(path);
        ext = _path.extname(path).substr(1);
        if (!_this.compilers.hasCompiler(ext)) {
          deferred.reject(new Error('File type ' + ext + ' is not supported'));
        } else {
          _this.loadFile(path).then(function(content) {
            if (content === null) {
              return deferred.resolve(null);
            } else {
              return deferred.resolve({
                path: path,
                content: content
              });
            }
          }, function(e) {
            return deferred.reject(e);
          });
        }
        return deferred.promise;
      })().then(function(file) {
        var deferred, name;
        if (file === null) {
          return Q.resolve(null);
        }
        deferred = Q.defer();
        name = _this.simq.getModuleName(file.path);
        if (base !== null) {
          name = name.replace(new RegExp('^' + base + '/'), '');
        }
        _this.compilers.compile(file.path, file.content).then(function(content) {
          return deferred.resolve('\'' + name + '\': function(exports, _r, module) {\nvar require = function(name) {return _r(name, \'' + name + '\');};\n\t\t' + content + '\n\t}');
        });
        return deferred.promise;
      });
    };

    Loader.prototype.loadModules = function(modules, base) {
      var deferred;
      if (base == null) {
        base = null;
      }
      deferred = Q.defer();
      this.processModules([], modules, 0, base, function(result) {
        return deferred.resolve(result);
      }, function(e) {
        return deferred.reject(e);
      });
      return deferred.promise;
    };

    Loader.prototype.processModules = function(result, files, num, base, finish, error) {
      var _this = this;
      if (base == null) {
        base = null;
      }
      if (files.length === 0 || num === files.length) {
        finish(result);
        return true;
      }
      return this.loadModule(files[num], base).then(function(content) {
        if (content !== null) {
          result.push(content);
        }
        return _this.processModules(result, files, num + 1, base, finish, error);
      }, function(e) {
        return error(e);
      });
    };

    return Loader;

  })();

  module.exports = Loader;

}).call(this);
