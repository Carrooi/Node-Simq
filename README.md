# SimQ - simple require for javascript (client)

## Installing

```
$ npm install -g simq
```

## Building

Merging all files into one will be helpful for client's browser (less http requests).

SimQ will automatically merge all your files into one for you.

```
$ cd /my/project/path
$ simq build
```

## Configuration - setup.json

The only thing what SimQ needs for run, is setup.json file, which contains configuration for your application.
The example below shows full configuration. Default file name is ./config/setup.json, but you can change it with --config param.
```
{
	"packages": {
		"application": {
			"application": "./Application.js",
			"style": {
				"in": "./css/style.less",
				"out": "./css/style.css"
			}
			"modules": [
				"./app/Application.js",
				"./app/controllers/",
				"./src/*.coffee",
				"./views/*.eco",
				"./config/database.json",
				"./lib/Spine/*.coffee"
			],
			"aliases": {
				"spine": "lib/Spine/spine"
			},
			"run": [
				"lib/Spine/ajax"
			],
			"libs": {
				"begin": [
					"http://code.jquery.com/jquery-1.10.1.js",
					"./lib/jqueryExtends.js"
				],
				"end": [
					"./lib/ckeditor.js"
				]
			}
		}
	},
	"template": {
		"jquerify": true
	},
	"debugger": {
		"styles": true,
		"scripts": true
	}
}
```

Application section holds name of final file.

SimQ can also compile you styles written in less, stylus or in sass (scss) css framework.

Modules section is array with list of all your own modules. More information about how to properly create module is bellow.
There are three ways how to define your modules. You can specify every module manually, or you can write just path to base dirs with slash in the end - this will load all modules in this folder recursively. The last possible way is to load everything from specified folder, but only files with given extension.

Some external libraries may use other module paths than paths generated by SimQ. Solution for this problem is using aliases for these cases. (eg: spine framework)

In section 'run', you can set names of modules, which should be called automatically on page load.

Last section defines other libraries and the place where they should be inserted. These libraries can also be
on some remote server, the only think what you have to do, is prefix them with proper protocol ("http://", "https://").

In this example you can also see all supported files: js, coffee, json and eco for templating. You can use even typescript
files, but this is little bit slow, because typescript package doesn't provide any API for other programmers. But cache
can help you with this (see below).

Other main sections (template and debugger) are explained bellow.

In modules section you can also use regular expressions enclosed with <>. Documentation in [fs-finder](https://npmjs.org/package/fs-finder).

```
"modules": {
	"./<(app|lib)>/*.<(coffee|eco)$>"
}
```

This will load all .coffee and .eco files in app or lib directory.

## Packages

In example above, we have got just one package called "application", but you can create as many independent packages,
as you wish.

```
{
	"packages": {
		"admin": {

		},
		"frontend": {

		}
	}
}
```

## Base namespace

If you have more packages in different folders and want to access your modules without prefixing them with base folder
name, you can set "base" in your package configuration. Path in "base" directive will be also prepended to all
external libraries

```
{
	"packages": {
		"new_site": {
			"base": "_NEW_SITE_FOLDER_"
		}
	}
}
```

## Including other config files

Look to the full documentation of [Easy Configuration](https://npmjs.org/package/easy-configuration#readme),
which is used for configuring SimQ.

## Module

Every module is simple javascript file. Here is example for hello word application.

```
// file app/helloWord.js

module.exports = function() {
	alert('hello word');
};
```

## Using module

```
<script type="text/javascript" src="Application.js"></script>
<script type="text/javascript">
	var hello = require('app/helloWord');

	hello();
</script>
```

You can notice that in require, we are not using any file extension - just like in node.
In SimQ you can also use relative paths. Here is an example of loading module validator from the same folder like form's
folder.

```
// module app/controllers/form/controls/form

(function() {

	var Validator = require('./validator');

})();
```

## Coffee script modules

```
# file app/helloWord.coffee

module.exports = -> alert 'hello word'
```

## Templating
SimQ includes eco template engine, so you can really simply require also your templates. Eco documentation: [link](https://github.com/sstephenson/eco#eco-embedded-coffeescript-templates).

Example of usage:
```
var data = {
	items: ['first', 'second', 'third']
}

$(require('views/menu')(data)).appendTo('body')
```

You can even tell SimQ to wrap automatically all templates into jQuery function. Example of config file:

```
{
	"packages": {

	},
	"template": {
		"jquerify": true
	}
}
```

Usage:

```
var html = (require('views/menu')(data)).html()
```

## Creating new application
SimQ can also help you with creating new application.

```
$ simq create my-application
```

## Watching for changes
It is also very simple to tell the SimQ to watch your files for changes. This is much easier than running 'simq build' after each change in your code.

```
$ cd /my/project/path
$ simq watch
```

## Compress result
In default, SimQ automatically compress result javascript file, but sometimes (for example for debug reasons), you may want to see it uncompressed.
This can be achieved by adding "debug" to build or watch command.

```
$ simq build --debug
```

Other way is to define it via config file, where you can set if you want to minify scripts, styles or both.

```
{
	"debugger": {
		"scripts": true,
		"styles": true
	}
}
```

## Cache
Large applications may be little slow, so there is posibility to turn on cache.

```
{
	"cache": {
		"directory": "./temp"
	}
}
```

You have to create temp directory and then set name of that directory to your config file. Than every file
(except style files) will be cached, so there is no need for rebuilding them every time.

Caching styles is little bit difficult because of the way style frameworks working (live importing files), so you need
to define all dependent style files for turn on cache for styles.
You can write each file or use regular expression ([documentation of fs-finder](https://npmjs.org/package/fs-finder)).

```
{
	"packages": {
		"styles": {
			"style": {
				"in": "./css/style.less",
				"out": "./css/style.css",
				"dependencies": [
					"./css/<*.less$>"
				]
			}
		}
	}
}
```

## Source maps
In debugger section, you can also allow source maps. For now, these are working only for less styles, which are using
sass source map syntax.
Source maps will be turned on only if debugger mode for styles is set to true.

```
{
	"debugger": {
		"styles": true,
		"sourceMap": true
	}
}
```